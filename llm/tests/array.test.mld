# Tests for @mlld/array module

@import { eq, deepEq, ok, notOk, includes, len } from @local/test
@import { filter, map, reduce, sum, avg, pluck, includes as arrIncludes, unique, flatten, groupBy } from @local/array

## Test filter
@data items = [
  {"name": "apple", "price": 1.50, "category": "fruit"},
  {"name": "banana", "price": 0.75, "category": "fruit"},
  {"name": "carrot", "price": 2.00, "category": "vegetable"}
]

@data fruits = @filter(@items, "category", "fruit")
@data test_filter_returns_array = @ok(Array.isArray(@fruits))
@data test_filter_correct_length = @eq(@len(@fruits), 2)
@data test_filter_correct_items = @deepEq(@pluck(@fruits, "name"), ["apple", "banana"])

# Test filter with empty array
@data emptyResult = @filter([], "key", "value")
@data test_filter_empty_array = @deepEq(@emptyResult, [])

## Test map
@exec double(n) = javascript [(return n * 2)]
@data numbers = [1, 2, 3, 4, 5]
@data doubled = @map(@numbers, @double)
@data test_map_doubles_numbers = @deepEq(@doubled, [2, 4, 6, 8, 10])

# Test map with objects
@exec getName(obj) = javascript [(return obj.name)]
@data names = @map(@items, @getName)
@data test_map_extracts_names = @deepEq(@names, ["apple", "banana", "carrot"])

## Test reduce
@exec sumReducer(acc, val) = javascript [(return acc + val)]
@data sumResult = @reduce(@numbers, @sumReducer, 0)
@data test_reduce_sum = @eq(@sumResult, 15)

# Test reduce with object accumulator
@exec countByCategory(acc, item) = javascript [(
  acc[item.category] = (acc[item.category] || 0) + 1;
  return acc;
)]
@data categoryCounts = @reduce(@items, @countByCategory, {})
@data test_reduce_counts = @deepEq(@categoryCounts, {"fruit": 2, "vegetable": 1})

## Test sum
@data priceSum = @sum(@items, "price")
@data test_sum_prices = @eq(@priceSum, 4.25)

# Test sum with array of numbers
@data numberSum = @sum(@numbers)
@data test_sum_numbers = @eq(@numberSum, 15)

## Test avg
@data priceAvg = @avg(@items, "price")
@data test_avg_prices = @ok(@priceAvg > 1.41 && @priceAvg < 1.42)  # ~1.416667

# Test avg with array of numbers
@data numberAvg = @avg(@numbers)
@data test_avg_numbers = @eq(@numberAvg, 3)

## Test pluck
@data categories = @pluck(@items, "category")
@data test_pluck_categories = @deepEq(@categories, ["fruit", "fruit", "vegetable"])

# Test pluck with missing field
@data missing = @pluck(@items, "nonexistent")
@data test_pluck_missing = @deepEq(@missing, [undefined, undefined, undefined])

## Test includes (array version)
@data hasApple = @arrIncludes(@pluck(@items, "name"), "apple")
@data test_includes_found = @ok(@hasApple)

@data hasOrange = @arrIncludes(@pluck(@items, "name"), "orange")
@data test_includes_not_found = @notOk(@hasOrange)

## Test unique
@data duplicates = ["a", "b", "a", "c", "b", "d"]
@data uniqueItems = @unique(@duplicates)
@data test_unique_removes_duplicates = @deepEq(@uniqueItems, ["a", "b", "c", "d"])

# Test unique with numbers
@data numberDupes = [1, 2, 3, 2, 4, 3, 5]
@data uniqueNumbers = @unique(@numberDupes)
@data test_unique_numbers = @deepEq(@uniqueNumbers, [1, 2, 3, 4, 5])

## Test flatten
@data nested = [[1, 2], [3, 4], [5]]
@data flat = @flatten(@nested)
@data test_flatten_simple = @deepEq(@flat, [1, 2, 3, 4, 5])

# Test flatten with mixed nesting
@data mixedNested = [1, [2, 3], [[4]], 5]
@data mixedFlat = @flatten(@mixedNested)
@data test_flatten_mixed = @deepEq(@mixedFlat, [1, 2, 3, [4], 5])

## Test groupBy
@data grouped = @groupBy(@items, "category")
@data test_groupBy_has_fruit = @ok(@grouped.fruit)
@data test_groupBy_has_vegetable = @ok(@grouped.vegetable)
@data test_groupBy_fruit_count = @eq(@len(@grouped.fruit), 2)
@data test_groupBy_vegetable_count = @eq(@len(@grouped.vegetable), 1)