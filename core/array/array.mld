---
name: array
description: 
author: adamavenir
mlld-version: 1.0.0-rc-12
---

>> Basic array operations
@exec length(array) = @run js [(Array.isArray(array) ? array.length : 0)]
@exec first(array) = @run js [(Array.isArray(array) && array.length > 0 ? JSON.stringify(array[0]) : "")]
@exec last(array) = @run js [(Array.isArray(array) && array.length > 0 ? JSON.stringify(array[array.length - 1]) : "")]
@exec at(array, index) = @run js [(Array.isArray(array) ? JSON.stringify(array[index]) : "")]
@exec slice(array, start, end) = @run js [(JSON.stringify(Array.isArray(array) ? array.slice(start, end) : []))]
@exec concat(array1, array2) = @run js [(JSON.stringify([...(Array.isArray(array1) ? array1 : []), ...(Array.isArray(array2) ? array2 : [])]))]

>> Array transformation
@exec reverse(array) = @run js [(JSON.stringify(Array.isArray(array) ? array.slice().reverse() : []))]
@exec sort(array) = @run js [(JSON.stringify(Array.isArray(array) ? array.slice().sort() : []))]
@exec sortBy(array, key) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? array.slice().sort((a, b) => {
          const aVal = a[key];
          const bVal = b[key];
          if (aVal < bVal) return -1;
          if (aVal > bVal) return 1;
          return 0;
        })
      : []
  )
)]
@exec unique(array) = @run js [(JSON.stringify(Array.isArray(array) ? [...new Set(array)] : []))]
@exec flatten(array) = @run js [(JSON.stringify(Array.isArray(array) ? array.flat() : []))]
@exec deepFlatten(array) = @run js [(JSON.stringify(Array.isArray(array) ? array.flat(Infinity) : []))]

>> Array filtering
@exec filter(array, key, value) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? array.filter(item => item[key] == value)
      : []
  )
)]
@exec filterGreater(array, key, value) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? array.filter(item => Number(item[key]) > Number(value))
      : []
  )
)]
@exec filterLess(array, key, value) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? array.filter(item => Number(item[key]) < Number(value))
      : []
  )
)]
@exec filterContains(array, key, substring) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? array.filter(item => String(item[key]).includes(substring))
      : []
  )
)]
@exec filterTruthy(array, key) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? array.filter(item => item[key])
      : []
  )
)]
@exec filterFalsy(array, key) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? array.filter(item => !item[key])
      : []
  )
)]

>> Array mapping
@exec pluck(array, key) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? array.map(item => item[key])
      : []
  )
)]
@exec map(array, fromKey, toKey) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? array.map(item => ({...item, [toKey]: item[fromKey]}))
      : []
  )
)]
@exec transform(array, key, prefix, suffix) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? array.map(item => ({
          ...item, 
          [key]: (prefix || '') + String(item[key]) + (suffix || '')
        }))
      : []
  )
)]

>> Array searching
@exec find(array, key, value) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? array.find(item => item[key] == value) || null
      : null
  )
)]
@exec findIndex(array, key, value) = @run js [(
  Array.isArray(array) 
    ? array.findIndex(item => item[key] == value)
    : -1
)]
@exec includes(array, value) = @run js [(
  Array.isArray(array) && array.includes(value) ? "true" : ""
)]
@exec includesAny(array, values) = @run js [(
  Array.isArray(array) && Array.isArray(values) && 
  values.some(v => array.includes(v)) ? "true" : ""
)]
@exec includesAll(array, values) = @run js [(
  Array.isArray(array) && Array.isArray(values) && 
  values.every(v => array.includes(v)) ? "true" : ""
)]

>> Array aggregation
@exec sum(array, key) = @run js [(
  Array.isArray(array) 
    ? array.reduce((sum, item) => sum + Number(key ? item[key] : item), 0)
    : 0
)]
@exec avg(array, key) = @run js [(
  Array.isArray(array) && array.length > 0
    ? array.reduce((sum, item) => sum + Number(key ? item[key] : item), 0) / array.length
    : 0
)]
@exec min(array, key) = @run js [(
  Array.isArray(array) && array.length > 0
    ? Math.min(...array.map(item => Number(key ? item[key] : item)))
    : null
)]
@exec max(array, key) = @run js [(
  Array.isArray(array) && array.length > 0
    ? Math.max(...array.map(item => Number(key ? item[key] : item)))
    : null
)]
@exec count(array, key, value) = @run js [(
  Array.isArray(array) 
    ? array.filter(item => (key ? item[key] == value : item == value)).length
    : 0
)]

>> Array grouping
@exec groupBy(array, key) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? array.reduce((groups, item) => {
          const group = String(item[key]);
          if (!groups[group]) groups[group] = [];
          groups[group].push(item);
          return groups;
        }, {})
      : {}
  )
)]
@exec partition(array, key, value) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? {
          true: array.filter(item => item[key] == value),
          false: array.filter(item => item[key] != value)
        }
      : { true: [], false: [] }
  )
)]

>> Array manipulation
@exec push(array, value) = @run js [(
  JSON.stringify([...(Array.isArray(array) ? array : []), value])
)]
@exec unshift(array, value) = @run js [(
  JSON.stringify([value, ...(Array.isArray(array) ? array : [])])
)]
@exec remove(array, index) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? array.filter((_, i) => i !== Number(index))
      : []
  )
)]
@exec removeValue(array, value) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? array.filter(item => item !== value)
      : []
  )
)]
@exec insert(array, index, value) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? [...array.slice(0, index), value, ...array.slice(index)]
      : [value]
  )
)]

>> Array utilities
@exec range(start, end, step) = @run js [(
  JSON.stringify(
    Array.from(
      { length: Math.ceil((end - start) / (step || 1)) },
      (_, i) => start + i * (step || 1)
    )
  )
)]
@exec repeat(value, count) = @run js [(
  JSON.stringify(Array(Number(count)).fill(value))
)]
@exec zip(array1, array2) = @run js [(
  JSON.stringify(
    Array.isArray(array1) && Array.isArray(array2)
      ? array1.map((item, i) => [item, array2[i]])
      : []
  )
)]
@exec chunk(array, size) = @run js [(
  JSON.stringify(
    Array.isArray(array) 
      ? Array.from({ length: Math.ceil(array.length / size) }, 
          (_, i) => array.slice(i * size, (i + 1) * size))
      : []
  )
)]

>> Clean API export
@data module = {
  >> Basic operations
  length: @length,
  first: @first,
  last: @last,
  at: @at,
  slice: @slice,
  concat: @concat,
  
  >> Transformation
  reverse: @reverse,
  sort: @sort,
  sortBy: @sortBy,
  unique: @unique,
  flatten: @flatten,
  deepFlatten: @deepFlatten,
  
  >> Filtering
  filter: @filter,
  filterGreater: @filterGreater,
  filterLess: @filterLess,
  filterContains: @filterContains,
  filterTruthy: @filterTruthy,
  filterFalsy: @filterFalsy,
  
  >> Mapping
  pluck: @pluck,
  map: @map,
  transform: @transform,
  
  >> Searching
  find: @find,
  findIndex: @findIndex,
  includes: @includes,
  includesAny: @includesAny,
  includesAll: @includesAll,
  
  >> Aggregation
  sum: @sum,
  avg: @avg,
  min: @min,
  max: @max,
  count: @count,
  
  >> Grouping
  groupBy: @groupBy,
  partition: @partition,
  
  >> Manipulation
  push: @push,
  unshift: @unshift,
  remove: @remove,
  removeValue: @removeValue,
  insert: @insert,
  
  >> Utilities
  range: @range,
  repeat: @repeat,
  zip: @zip,
  chunk: @chunk
}